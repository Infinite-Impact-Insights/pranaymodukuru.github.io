[{"authors":["admin"],"categories":null,"content":"I am a Master\u0026rsquo;s student at Fachhochschule Südwestfalen, currently doing Master Thesis in the field of Deep Learning.\nI am working as a research assistant in the field Automation Technology, developing deep learning and machine learning algorithms for condition monitoring and predictive maintenance for Industry 4.0.\nI am proficient in Deep Learning, Machine Learning, Data Analysis and Visualization.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://pranaymodukuru.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a Master\u0026rsquo;s student at Fachhochschule Südwestfalen, currently doing Master Thesis in the field of Deep Learning.\nI am working as a research assistant in the field Automation Technology, developing deep learning and machine learning algorithms for condition monitoring and predictive maintenance for Industry 4.0.\nI am proficient in Deep Learning, Machine Learning, Data Analysis and Visualization.","tags":null,"title":"Naga Sai Pranay Modukuru","type":"authors"},{"authors":["Pranay Modukuru"],"categories":[],"content":"The Optimization Problem In simple words, finding a minimum value for a given equation is considered as optimization. This has many applications in real life - finding the fastest path when traveling from one place to other, job shop scheduling, air traffic management etc,. The optimization has been the back bone of machine learning, where the algorithms are expected to extract knowledge from huge volumes of data.\nOptimization plays a major role Neural Networks, where there are millions of parameters and the goal is to find the right set of parameters to correctly represent the data. There has been a lot of research in this field and many algorithms have been developed for effective optimization. Even though the performance of the optimizer has improved a lot, there is another problem that the optimization depends upon i.e. the initial point. The trajectory of optimization is largely dependant on the initialisation. This has been studied and numerous initialization techniques have been proposed to effectively exploit the power of optimization algorithms.\nIn this post we are going to see how the initialization can affect the performance of some of the optimization algorithms until day. Although, we are using a two dimensional problem here since it is easy to visualize, the initialization problem becomes more prevalent when there are millions of parameters (Neural Networks).\nThe Task Initialize x, y and use gradient descent algorithms to find the optimal values of x and y such that the value of the Beale function is zero (or as low as possible).\nA brief introduction to optimization algorithms We are going to consider three popular optimization algorithms, since we are more concerned about the initialization these will be sufficient for our analysis.\n Stochastic Gradient Descent - The stochastic gradient descent (SGD) algorithm performs one update at a time computing gradients at each step. Momentum - Overcomes the difficulty of slow updates of stochastic gradient descent by considering the momentum of gradients over a period of time. Adam - Considered to be the most popular optimization algorithm. It takes into consideration the first and second moments i.e. the exponentially decaying average of past gradients and squared gradients.  A more detailed explanation about gradient descent optimization algorithms, please read this post by Sebastian Ruder.\nImporting required libraries We are going to use the autograd functionality of PyTorch for getting the gradients and matplotlib for plotting the trajectories.\nimport torch\rimport numpy as np\rimport matplotlib.pyplot as plt\rimport seaborn as sns\rfrom mpl_toolkits.mplot3d import Axes3D\rfrom matplotlib.colors import LogNorm\rimport warnings\rwarnings.filterwarnings(\u0026quot;ignore\u0026quot;)\r The Beale Function $$ f(x, y) = (1.5 - x + xy)^2 + (2.25 - x + xy^2)^2 +(2.625 - x + xy^3)^2\\tag{1} $$\n Beale function is a multimodal non-convex continuous function defined in two dimensions. It is usually evaluated in the range $(x, y) \\in [-4.5, 4.5]$. The function has only one global minimum at $(x, y) = (3, 0.5)$.  The Beale Function, a two dimentional function is chosen to make visualizations simple.\nVisualizing the Beale Function As the Beale function is a two variable function ranging between -4.5 and 4.5, we can generate a meshgrid using numpy to pass all the possible values of x and y to the function. This enables us to have the output of the beale\u0026rsquo;s function at each possible point, we can use these outputs to visualize the function in a contour plot.\nAs we are relating the optimization problem with neural networks, we will refer to (x, y) as (w1 , w2). Also, when using a neural network we refer to objective function as a loss function and the output of the function as loss. In this case, we refer to the Beale\u0026rsquo;s function as loss function and the outputs as losses\n# Defining function\rf = lambda x, y: (1.5 - x + x*y)**2 + (2.25 - x + x*y**2)**2 + (2.625 - x + x*y**3)**2\r# Defining the range of w1 and w2, step size\rw1_min, w1_max, w1_step = -4.5, 4.5, .2\rw2_min, w2_max, w2_step = -4.5, 4.5, .2\r# Global minima of the function\rminima_ = [3, 0.5]\r# generating meshgrid\rw1, w2 = np.meshgrid(np.arange(w1_min, w1_max + w1_step, w1_step),\rnp.arange(w2_min, w2_max + w2_step, w2_step))\rlosses = f(w1, w2)\r We will now plot the losses on a contour plot with the following code.\nfig, ax = plt.subplots(figsize=(10, 6))\rax.contour(w1, w2, losses, levels=np.logspace(0, 5, 35),\rnorm=LogNorm(), cmap=plt.cm.jet, alpha = 0.8)\rax.plot(*minima_, 'r*', color='r',\rmarkersize=10, alpha=0.7, label='minima')\rax.set_xlabel('w1')\rax.set_ylabel('w2')\rax.set_xlim((w1_min, w1_max))\rax.set_ylim((w2_min, w2_max))\rax.legend(bbox_to_anchor=(1.2, 1.))\rax.set_title(\u0026quot;Beale Function\u0026quot;)\rfig.tight_layout(rect=[0, 0.03, 1, 0.95])\r Output As seen in the image, blue region indicates lower values and the red region is higher values of the Beale\u0026rsquo;s function. The minima (3, 0.5) is indicated with a star.\n\r\r\rSetting up Parameters As we are using PyTorch, we need to have parameters that are to be optimized put into a nn.Module class. The __init__() takes (x, y) as inputs to initialize the parameters (w1, w2). Also, we are going to write the beale\u0026rsquo;s equation in the forward function.\nclass Net_Beale(torch.nn.Module):\rdef __init__(self, x, y):\rsuper(Net_Beale, self).__init__()\rself.w1 = torch.nn.Parameter(torch.tensor([x]))\rself.w2 = torch.nn.Parameter(torch.tensor([y]))\rdef forward(self):\r# Beale Function Equation\ra = (1.5 - self.w1 + self.w1*self.w2)**2\rb = (2.25 - self.w1 + self.w1*self.w2**2)**2\rc = (2.625 - self.w1 + self.w1*self.w2**3)**2\rreturn a+b+c\r Optimizing and Saving Trajectory Since we are interested in tracking the path of the optimization, we need to collect the parameters at each step/desired steps and save them for plotting.\nThe below function initialises the parameters of the network, initializes an optimizer and runs the optimization for the specified number of steps while collecting the path of the parameters.\ndef get_trajectory(x, y, optim, lr, epochs, interval=1):\r# Initialize Network\rnet = Net_Beale(x,y)\r# Initialize Optimizer\rif optim == \u0026quot;sgd\u0026quot;:\roptim = torch.optim.SGD(net.parameters(), lr)\relif optim == \u0026quot;mom\u0026quot;:\roptim = torch.optim.SGD(net.parameters(), lr, momentum=0.9)\relif optim == \u0026quot;adam\u0026quot;:\roptim = torch.optim.Adam(net.parameters(), lr)\r# Initialize Trackers\rw_1s = []\rw_2s = []\r# Run Optimization\rfor i in range(epochs):\roptim.zero_grad()\ro = net()\ro.backward()\rif i % interval == 0:\r# Append current w1 and w2 to trackers\rw_1s.append(net.w1.item())\rw_2s.append(net.w2.item())\roptim.step()\rw_1s.append(net.w1.item())\rw_2s.append(net.w2.item())\r# Join w1's and w2's into one array\rtrajectory = np.array([w_1s, w_2s]) return trajectory\r Comparision between trajectories After collecting the paths of parameters with different algorithms, we are going to plot them on the Beale Function Contour plot. The below function takes in the initial position, list of optimizers and corresponding learning rates and epochs and plots the trajectories of algorithms with specified settings.\ndef compare_trajectories(x, y, epochs, optims, lrs):\rcolors = ['k', 'g', 'b', 'r', 'y', 'c', 'm']\rtrajectories = []\rnames = []\r# Loop on all optimizers in list\rfor ep, optim, lr in zip(epochs, optims, lrs):\rtrajectory = get_trajectory(float(x), float(y), optim=optim, lr=lr, epochs=ep)\rnames.append(optim)\rtrajectories.append(trajectory)\r# Plot the Contour plot of Beale Function and trajectories of optimizers\rfig, ax = plt.subplots(figsize=(10, 6))\rax.contour(w1, w2, losses, levels=np.logspace(0, 5, 35),\rnorm=LogNorm(), cmap=plt.cm.jet, alpha = 0.5)\rfor i, trajectory in enumerate(trajectories):\rax.quiver(trajectory[0,:-1], trajectory[1,:-1], trajectory[0,1:]-trajectory[0,:-1],\rtrajectory[1,1:]-trajectory[1,:-1], scale_units='xy', angles='xy', scale=1,\rcolor=colors[i], label=names[i], alpha=0.8)\rstart_ =[x,y]\rax.plot(*start_, 'r*', color='k',markersize=10, alpha=0.7, label='start')\rax.plot(*minima_, 'r*', color='r',markersize=10, alpha=0.7, label='minima')\rax.set_xlabel('w1')\rax.set_ylabel('w2')\rax.set_xlim((w1_min, w1_max))\rax.set_ylim((w2_min, w2_max))\rax.set_title(\u0026quot;Initial point - ({},{})\u0026quot;.format(x,y))\rax.legend(bbox_to_anchor=(1.2, 1.))\rfig.suptitle(\u0026quot;Optimization Trajectory\u0026quot;)\rfig.tight_layout(rect=[0, 0.03, 1, 0.95])\r Trying Different Initial Points After setting up everything, we are now ready to compare the three algorithms with different initial points.\nThe learning rates observed to be working in this problem\n SGD - 0.0001 momentum - 0.0001 Adam - 0.01  We are going to use the same learning rate for different initial points considered for respective algorithms to keep the analysis simple and since we are not doing hyperparameter tuning. Feel free to download this notebook and trying out different hyperparameters and initial points.\n# Settings for optimizers\repochs = [10000] * 3\roptims = ['sgd', 'mom', 'adam']\rlrs = [0.0001, 0.0001, 0.01]\r Case 1 : A point close to minima # A point closer to minima\rx = 2.5\ry = 2.\rcompare_trajectories(x, y, epochs, optims, lrs)\r \r\r\rAll the three reach the global minima, lets move a little further and see what happens.\nCase 2 : Moving a little further # A little away in the same region\rx = 1.5\ry = 2.5\rcompare_trajectories(x, y, epochs, optims, lrs)\r \r\r\rMoving a little further from where we have started has made a huge difference on how an optimizer moves the parameters towards minimum. As seen in the figure above adam optimizer moves towards a local minimum and is stuck there, whereas sgd and momentum reach the global minimum. Things to notice, we are not changing the learning rate here, as we are focusing on effect of initialization on optimization.\nCase 3 : Moving a little further # Lower left region\rx = -4\ry = -4\rcompare_trajectories(x, y, epochs, optims, lrs)\r \r\r\r(more example can be found in this notebook)\nConclusion The initial point plays a crucial role in optimization problems. Here we are trying to solve a two dimensional problem which is fairly easy when compared to finding a minima when we have a large dataset and more than million parameters (dimensions).\nAlthough we are not tuning the hyperparameters here, we can effectively drive the optimization in right direction with the right set of hyperparameters.\nReferences  https://mitpress.mit.edu/books/optimization-machine-learning https://en.wikipedia.org/wiki/Test_functions_for_optimization http://benchmarkfcns.xyz/benchmarkfcns/bealefcn.html https://ruder.io/optimizing-gradient-descent/ http://louistiao.me/notes/visualizing-and-animating-optimization-algorithms-with-matplotlib/ https://communities.sas.com/t5/SAS-Communities-Library/Mathematical-Optimization-in-our-Daily-Lives/ta-p/504724#  ","date":1583369632,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583369632,"objectID":"d5ad83971469d63a53d5ff519295e9b6","permalink":"https://pranaymodukuru.github.io/post/optimization-trajectory/","publishdate":"2020-03-05T01:53:52+01:00","relpermalink":"/post/optimization-trajectory/","section":"post","summary":"The purpose of this post is to demonstrate the importance of Initialization","tags":["Deep Learning","Optimization","First post"],"title":"Effect of Initialization on Optimization Trajectory","type":"post"},{"authors":null,"categories":null,"content":"Deep Learning has transformed many domains such as Image Processing, Computer Vision, Natural Language Processing. Removing noise from images has been a reasonably tough task until the deep learning based auto encoders transformed the image processing field.\nI used a Deep Convolutional Autoencoder to remove coffe stains, footprints, marks resulting from folding or wrinkles from scanned office documents.\nCheck out the project on github.\n","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575158400,"objectID":"b1f360d9383396416b3dd170d31c1d9f","permalink":"https://pranaymodukuru.github.io/project/denoising-auto-encoder/","publishdate":"2019-12-01T00:00:00Z","relpermalink":"/project/denoising-auto-encoder/","section":"project","summary":"Removing noise/dirt marks from scanned documents using Deep Autoencoder.","tags":["Deep Learning","Machine Learning","Autoencoder","Denoising","Image processing"],"title":"Denoising Autoencoder","type":"project"},{"authors":null,"categories":null,"content":"Gesture Recognition is an important application in many domains. For example:\n In games, to enable the player to control game elements with hand In cars, for touch-less dashboards and enhanced safety In Language, identifying sign languages \u0026hellip;  In this project, I collected hand gesture images from my laptop\u0026rsquo;s webcam and trained a Convolutional Neural Network (CNN) to recognize these gestures.\nMy future plan is to use the trained CNN in a game, to predict the hand gestures in real-time.\nCheck out the project on github.\n","date":1575158400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575158400,"objectID":"58eb9bbf2d45fccfd9b3d93582e8d8c6","permalink":"https://pranaymodukuru.github.io/project/hand-gesture-recognition/","publishdate":"2019-12-01T00:00:00Z","relpermalink":"/project/hand-gesture-recognition/","section":"project","summary":"Recognizing Hand Gestures with Convolutional Neural Networks.","tags":["Deep Learning","Machine Learning","Gesture Recognition"],"title":"Hand Gesture Recognition","type":"project"},{"authors":null,"categories":null,"content":"Measuring Rotor temperature of any motor is difficult. As the rotor is continuously rotating and attaching any sensor to it would be difficult. Also, knowing the rotor\u0026rsquo;s temperature would enable efficient control of the motor.\nFor this reason, predicting the rotors temperature using machine learning would benefit in designing of the motor with minimal equipment and helps in efficient control of the motor.\nCheck out the project on github.\n","date":1569888000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1569888000,"objectID":"c408771c433616ff6f4ba074e750692a","permalink":"https://pranaymodukuru.github.io/project/pmsm-rotor-temperature/","publishdate":"2019-10-01T00:00:00Z","relpermalink":"/project/pmsm-rotor-temperature/","section":"project","summary":"Predicting rotor temperature of a Permanent Magnet Synchronous Motor (PMSM) with Convolutional Neural Networks.","tags":["Deep Learning","Machine Learning","Industry 4.0","Soft Sensor"],"title":"PMSM Rotor Temperature Prediction","type":"project"}]